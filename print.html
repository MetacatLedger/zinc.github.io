<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ZRust</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="index.html">Introduction</a></li><li><a href="01-design-background.html"><strong aria-hidden="true">1.</strong> Design background</a></li><li><a href="02-basic-concepts/00-overview.html"><strong aria-hidden="true">2.</strong> Getting started</a></li><li><ol class="section"><li><a href="02-basic-concepts/01-input-output.html"><strong aria-hidden="true">2.1.</strong> Inputs, witnesses and output</a></li><li><a href="02-basic-concepts/02-standard-library.html"><strong aria-hidden="true">2.2.</strong> Standard library</a></li></ol></li><li><a href="03-examples/00-overview.html"><strong aria-hidden="true">3.</strong> Examples</a></li><li><ol class="section"><li><a href="03-examples/01-binary.html"><strong aria-hidden="true">3.1.</strong> Binary</a></li><li><a href="03-examples/02-library.html"><strong aria-hidden="true">3.2.</strong> Library</a></li></ol></li><li><a href="04-variables-and-types/00-overview.html"><strong aria-hidden="true">4.</strong> Variables and types</a></li><li><ol class="section"><li><a href="04-variables-and-types/01-variables.html"><strong aria-hidden="true">4.1.</strong> Variables</a></li><li><a href="04-variables-and-types/02-types/00-overview.html"><strong aria-hidden="true">4.2.</strong> Types</a></li><li><ol class="section"><li><a href="04-variables-and-types/02-types/01-scalar.html"><strong aria-hidden="true">4.2.1.</strong> Scalar</a></li><li><a href="04-variables-and-types/02-types/02-compound.html"><strong aria-hidden="true">4.2.2.</strong> Compound</a></li><li><a href="04-variables-and-types/02-types/03-custom.html"><strong aria-hidden="true">4.2.3.</strong> Custom</a></li><li><a href="04-variables-and-types/02-types/04-other.html"><strong aria-hidden="true">4.2.4.</strong> Other</a></li></ol></li></ol></li><li><a href="05-statements/00-overview.html"><strong aria-hidden="true">5.</strong> Statements</a></li><li><ol class="section"><li><a href="05-statements/01-declaration.html"><strong aria-hidden="true">5.1.</strong> Declaration</a></li><li><a href="05-statements/02-expression.html"><strong aria-hidden="true">5.2.</strong> Expression</a></li><li><a href="05-statements/03-control.html"><strong aria-hidden="true">5.3.</strong> Control</a></li></ol></li><li><a href="06-operators/00-overview.html"><strong aria-hidden="true">6.</strong> Operators</a></li><li><ol class="section"><li><a href="06-operators/01-precedence.html"><strong aria-hidden="true">6.1.</strong> Precedence</a></li></ol></li><li><a href="07-expressions/00-overview.html"><strong aria-hidden="true">7.</strong> Expressions</a></li><li><a href="08-virtual-machine/00-overview.html"><strong aria-hidden="true">8.</strong> Virtual machine</a></li><li><a href="appendix/_overview.html"><strong aria-hidden="true">9.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix/A-grammar-lexical.html"><strong aria-hidden="true">9.1.</strong> A - Lexical grammar</a></li><li><a href="appendix/B-grammar-syntax.html"><strong aria-hidden="true">9.2.</strong> B - Syntax grammar</a></li><li><a href="appendix/C-keywords.html"><strong aria-hidden="true">9.3.</strong> C - Keywords</a></li><li><a href="appendix/D-built-in-functions.html"><strong aria-hidden="true">9.4.</strong> D - Built-in functions</a></li></ol></li><li><a href="compiler.html">Compiler CLI</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">ZRust</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <img style="display: block; margin: auto;" width="200" height="200" src="./zrust-color.png"/>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Recent rapid advances in R1CS-based SNARKs finally make application of
zero-knowledge proofs practical for bringing scalability and privacy to blockchains.</p>
<p>At the same time, most existing languages and frameworks for constructing R1CS
circuits, while being useful in academic research and prototyping, do not
provide a satisfying degree of expressiveness and brevity to write readable and
easily maintainable programs. A notable exception is <em>xJsnark</em>, but being
based on Java it lacks a lot of safety features of modern functional languages.</p>
<p>Further, existing frameworks completely lack functionality specific for
smart contracts. Security and safety aspects are crucial for developing smart
contracts since they deal with valuable financial assets. Modern smart contract
languages, such as <em>Simplicity</em> or Libra's <em>Move</em>, deliberately made design
choices that favor safety and formal verifiability of the code over generalistic
expressiveness.</p>
<p>ZRust was created to fill the gap between these two worlds: provide a smart
contract language optimized for R1CS circuits, which is reliable and simple at
the same time, and can be quickly learned by a large number of software developers.</p>
<p>We decided to borrow the Rust syntax and semantics. ZRust is a subset of Rust
with minor differences dictated by the subtleties of R1CS circuits. It is easily
learnable by any developer familiar with Rust, Golang, C++ or other C-like
languages. Also, experience with Solidity will help in understanding some smart
contract specifics.</p>
<p>The language is under heavy development, so many of its aspects will eventually
be improved or changed. However, the basic principles, such as security and
simplicity, will never be questioned.</p>
<h1><a class="header" href="#design-background" id="design-background">Design background</a></h1>
<p>The goal of ZRust is to make writing safe zero-knowledge programs and ZKP-based
smart contracts easy. It has been designed with the following principles in mind:</p>
<ul>
<li><strong>Security</strong>. It should be easy to write deterministic and secure programs.
Conversely, it should be hard to write code to exploit some possible
vulnerabilities found in other programming languages.</li>
<li><strong>Safety</strong>. The language must enforce the most strict semantics available,
such as a strong static explicit type system.</li>
<li><strong>Efficiency</strong>. The code should compile to the most efficient circuit possible.</li>
<li><strong>Cost-exposition</strong>. Performance costs that cannot be optimized efficiently
must be made explicit to the developers. An example is the requirement to
explicitly specify the loop range with constants.</li>
<li><strong>Simplicity</strong>. Anyone familiar with C-like languages (Javascript, Java,
Golang, C++, Rust, Solidity, Move) should be able to learn ZRust quickly and
with minimum effort.</li>
<li><strong>Readability</strong>. The code in ZRust should be easily readable to anybody
familiar with the C++ language family. There should be no counter-intuitive concepts.</li>
<li><strong>Minimalism</strong>. Less code is better. There should ideally be only one way to
do something efficiently. Complexity should be reduced.</li>
<li><strong>Expressiveness</strong>. The language should be powerful enough to make building
complex programs easy.</li>
<li><strong>Turing incompleteness</strong>. Unbounded looping and recursion are not permitted
in ZRust. This not only allows more efficient R1CS circuit construction but
also makes formal verifiability about the call and stack safety easier and
eliminates the gas computation problem inherent to Turing-complete smart
contract platforms, such as EVM.</li>
</ul>
<h1><a class="header" href="#key-features" id="key-features">Key features</a></h1>
<ul>
<li>Type safety</li>
<li>Type inference</li>
<li>Immutability</li>
<li>Movable resources as a first-class citizen</li>
<li>Module definition and import</li>
<li>Expressive syntax</li>
<li>Industrial-grade compiler optimizations</li>
<li>Turing incompleteness: no recursion or unbounded looping</li>
<li>Flat learning curve for Rust/JS/Solidity/C++ developers</li>
</ul>
<h1><a class="header" href="#comparison-to-rust" id="comparison-to-rust">Comparison to Rust</a></h1>
<p>ZRust is designed specifically for ZK-circuits and ZKP-based smart contract
development, so some differences from Rust are inevitable.</p>
<h2><a class="header" href="#type-system" id="type-system">Type system</a></h2>
<p>We need to adapt the type system to be efficiently representable in
finite fields, which are the basic building block of R1CS. The current type
system mostly follows Rust, but some aspects are borrowed from smart contract
languages. For example, ZRust provides integer types with 1-byte step sizes,
like those in Solidity.</p>
<h2><a class="header" href="#ownership-and-borrowing" id="ownership-and-borrowing">Ownership and borrowing</a></h2>
<p>Memory management is very different in R1CS
circuits compared to the von Neumann architecture. Also, since R1CS does not
imply parallel programming patterns, a lot of elements of the Rust design would
be unnecessary and redundant. ZRust has no ownership mechanism found in Rust
because all variables will be passed by value. The borrowing mechanism is still
being designed, but probably, only immutable references will be allowed shortly.</p>
<h2><a class="header" href="#loops-and-recursion" id="loops-and-recursion">Loops and recursion</a></h2>
<p>ZRust is a Turing-incomplete language, as it does not allow recursion and
variable loop indexes. Each loop range must be bounded with constant literals
or expressions.</p>
<h1><a class="header" href="#getting-started" id="getting-started">Getting started</a></h1>
<p>A ZRust project consists of a binary file called <code>main.zrs</code> and zero or more
library files whose contents can be imported into the binary file.</p>
<p>The binary file must contain the <code>main</code> function, which accepts input and witness
data, and returns the output data.</p>
<p>Library files may contain only declarations of types, functions, and constants.</p>
<h2><a class="header" href="#zargo-build-tool" id="zargo-build-tool">Zargo build tool</a></h2>
<p>The Zargo build tool is the ZRust project builder which will be available soon.
It is being designed after the <code>cargo</code> tool from the Rust ecosystem.</p>
<h1><a class="header" href="#inputs-witnesses-and-the-output" id="inputs-witnesses-and-the-output">Inputs, witnesses and the output</a></h1>
<p>Public inputs (defined as the <code>Input</code> type) and secret witness (defined as the
<code>Witness</code> type) are the arguments of the program for which the circuit is
implemented. The prover must provide both public inputs and secret witness data
in order to generate proofs. The verifier must provide the same public input
to verify the satisfiability of the proof.</p>
<p>The output data defined as the <code>Output</code> type contain the result of a
circuit execution.</p>
<p>Actually, input, witness, and output can be of any type, but using
structures is considered a good design as it makes their use in the code more
explicit.</p>
<pre><code class="language-rust no_run noplaypen">struct Input {
    {identifier}: {type},
    ...
}

struct Witness {
    {identifier}: {type},
    ...
}

struct Output {
    {identifier}: {type},
    ...
}

fn main(input: Input, witness: Witness) -&gt; Output { Output { ... } }
</code></pre>
<h1><a class="header" href="#standard-library" id="standard-library">Standard library</a></h1>
<p>The standard library is currently limited to several built-in functions embedded
into the ZRust VM. </p>
<h2><a class="header" href="#built-in-functions" id="built-in-functions">Built-in functions</a></h2>
<p>Built-in functions closely resemble <code>macro_rules</code> found in Rust, but you do not
have to declare them since the compiler already knows all the built-in function
signatures.</p>
<p>Among these functions are:</p>
<ul>
<li>helper ones: <code>dbg</code>, <code>assert</code>, etc.</li>
<li>hashing ones: <code>sha256</code>, <code>pedersen</code>, <code>rescue</code>, etc.</li>
</ul>
<p>The exhaustive list of function signatures is provided in the <strong>Appendix D</strong>.</p>
<p>To call such a function, use the Rust macro syntax, as in the following example:</p>
<pre><pre class="playpen"><code class="language-rust">fn main(input: field) {
    let input_sha256 = sha256!(input);
    dbg!(input_sha256);

    let input_pedersen = pedersen!(input);
    dbg!(input_pedersen);

    let input_rescue = rescue!(input);
    assert!(input_rescue == SOME_RESULT);
}
</code></pre></pre>
<h1><a class="header" href="#examples" id="examples">Examples</a></h1>
<p>The examples in this chapter will illustrate various ZRust concepts and help you
to understand its advantages. Also, there is a ZRust playground under
development which will allow you to try everything yourself.</p>
<h1><a class="header" href="#binary" id="binary">Binary</a></h1>
<pre><code class="language-rust no_run noplaypen">/// 
/// './main.rs'
///
/// Proves a knowledge of a cubic root `r` for a given public input `x`.
///

mod simple_math;

use simple_math::cube;

struct Input {
    x: u128,
}

struct Witness {
    r: u128,
}

struct Output {}

fn main(input: Input, witness: Witness) -&gt; Output {
    require(x == cube(r), &quot;x == r ^ 3&quot;);
    Output {}
}
</code></pre>
<h1><a class="header" href="#library" id="library">Library</a></h1>
<pre><code class="language-rust no_run noplaypen">/// 
/// './lib.rs'
/// 
/// Returns x^3.
/// 
fn cube(x: u128) -&gt; u128 {
    let mut r = x;
    for i in 0..2 {
        r = r * x;
    }
    r
}
</code></pre>
<h1><a class="header" href="#variables-and-types" id="variables-and-types">Variables and types</a></h1>
<p>This chapter describes the ZRust language concepts. Here you will learn about
variables and types.</p>
<h1><a class="header" href="#variables" id="variables">Variables</a></h1>
<p>As it was said before, ZRust is mostly about safety and security. Thus,
variables are immutable by default. If you are going to change their values,
you must explicitly mark them as mutable. It protects your data from accidental
mutating where the compiler is unable to check your intentions.</p>
<pre><code class="language-rust no_run noplaypen">fn test() {
    let x = 0;
    // compile error: mutating an immutable variable
    // x = 42;

    let mut y = 0;
    y = 42; // ok
}
</code></pre>
<p>If you are familiar with Rust, you will not have any trouble understanding this
concept, since the syntax and semantics are almost identical. However, pattern
matching and destructuring are not implemented yet.</p>
<p>Immutable variables are similar to constants. Like with constants, you cannot
change the immutable variable value. However, constants have some further
restrictions: they cannot infer their type, can be declared only in the global
scope, and obviously cannot be marked as mutable.</p>
<p>In contrast to Rust, variables can only be declared in functions. If you need a
global variable, you should declare a constant. This limitation is devised to
prevent unwanted side effects, polluting the global namespace, and bad design.</p>
<pre><code class="language-rust no_run noplaypen">const VALUE: field = 0; // ok

fn test() {
    // compile error: a constant not in the global scope
    // const VALUE: field = 0;
}
</code></pre>
<p>Variable shadowing can be a convenient feature, but ZRust is going to enforce
warning-as-error development workflow, forbidding shadowing as a potentially
unsafe trick. You should use mutable variables and type suffixes if you have
several variables with similar logical meaning.</p>
<pre><code class="language-rust no_run noplaypen">fn test() {
    let mut x = 5;
    {
        // compile error: redeclared variable 'x'
        // let x = 25;
    }
    // compile error: redeclared variable 'x'
    // let x = 25;

    x = 25; // ok
}
</code></pre>
<h1><a class="header" href="#types" id="types">Types</a></h1>
<p>ZRust is a statically typed language, thus all the variables must have a type
known at the compile time. Strict type system allows to catch the majority of
runtime errors, which are very common to dynamically typed languages. ZRust type
system closely resembles that of Rust, but with some modifications, limitations,
and restrictions.</p>
<p>Types are divided into three major classes: scalar, compound, and custom.
Unit, boolean, integer, and string are the scalar types and you can learn more
about them in <strong>subchapter 1</strong>.
Arrays and tuples are the compound types explained in <strong>subchapter 2</strong>.
Structures, enumerations, and functions are custom types described in <strong>subchapter 3</strong>.
Custom types differ from others in having a user-defined name and special
declaration syntax.
The string type does not belong to any of the classes described above since
it is used mostly to annotate statements and provide error messages. For more
details, check the <strong>subchapter 4</strong>.</p>
<p>You can also declare type aliases in ZRust, which allow you to shorten type
signatures of complex types by giving them a name:</p>
<pre><code class="language-rust no_run noplaypen">type ComplexType = [(u8, [bool; 8], field); 16];

fn example(data: ComplexType) {}
</code></pre>
<h2><a class="header" href="#casting-and-conversions" id="casting-and-conversions">Casting and conversions</a></h2>
<p>The language enforces static strong explicit type semantics. It is the most
strict type system available since reliability is above everything. However,
some inference abilities will not do any harm, so you do not have to specify
types in places where they are highly obvious.</p>
<h3><a class="header" href="#explicit" id="explicit">Explicit</a></h3>
<p>Type conversions can be only performed on the integer and enumeration types with
the casting operator. <strong>Chapter 5</strong> explains the operator behavior in details.</p>
<h3><a class="header" href="#implicit" id="implicit">Implicit</a></h3>
<p>The <code>let</code> statement can perform implicit type casting of integers if the type
is specified to the left of the assignment symbol. Let us examine the statement:</p>
<pre><code class="language-rust no_run noplaypen">let a: field = 42 as u32;
</code></pre>
<ol>
<li><code>42</code> is inferred as a value of type <code>u8</code>.</li>
<li><code>42</code> is casted from <code>u8</code> to <code>u32</code>.</li>
<li>The expression <code>42 as u32</code> result is casted to <code>field</code>.</li>
<li>The field value is assigned to the variable <code>a</code>.</li>
</ol>
<p>The second case of implicit casting is the negation operator, which always
returns a signed integer type value of the same bitlength, regardless of the
input argument.</p>
<pre><code class="language-rust no_run noplaypen">let positive = 100; // u8
let negative = -positive; // i8
</code></pre>
<p><strong>Chapter 5</strong> explains the negation operator with more detail.</p>
<h3><a class="header" href="#inference" id="inference">Inference</a></h3>
<p>For now, ZRust infers types in two cases: integer literals and <code>let</code> bindings.</p>
<p>Integer literals are always inferred as values of the minimal possible size.
That is, <code>255</code> is a <code>u8</code> value, whereas <code>256</code> is a <code>u16</code> value. Signed integers
must be implicitly casted using the negation operator.</p>
<p>The <code>let</code> statement can infer types in case its type is not specified.</p>
<pre><code class="language-rust no_run noplaypen">let value = 0xffffffff_ffffffff_ffffffff_ffffffff;
</code></pre>
<p>In the example above, the <code>value</code> variable gets type <code>u128</code>, since 128 bytes
are enough to represent the value <code>0xffffffff_ffffffff_ffffffff_ffffffff</code>;</p>
<h1><a class="header" href="#scalar-types" id="scalar-types">Scalar types</a></h1>
<p>Scalar types are also called primitive types and contain a single value.</p>
<h2><a class="header" href="#unit" id="unit">Unit</a></h2>
<p>The unit type and value are described with empty round parenthesis <code>()</code> and
have no differences from the same type in Rust. Values of that type are
implicitly returned from functions, blocks, and other expressions which do not
return a value explicitly. Also, this type can be used as a placeholder for
input, witness and output types of the <code>main</code> function.</p>
<p><code>()</code> is the literal for both unit type and value. The unit type values cannot be
used by any operators or casted back and forth.</p>
<p>The unit type can exist as a standalone value:</p>
<pre><code class="language-rust no_run noplaypen">let x = (); // ()
</code></pre>
<p>It can be returned by blocks or functions:</p>
<pre><code class="language-rust no_run noplaypen">fn check(value: bool) {
    // several statements
};

let y = check(true); // y is ()
</code></pre>
<h2><a class="header" href="#boolean" id="boolean">Boolean</a></h2>
<p><code>bool</code> is the boolean type keyword.</p>
<p>Its internal representation uses the BN256 field of bitlength <code>1</code>. But in
general, its behavior is indistinguishable from the same type from Rust or other
C-like languages.</p>
<p>Boolean values cannot be casted to or from.</p>
<h3><a class="header" href="#literals" id="literals">Literals</a></h3>
<p><code>true</code> and <code>false</code>.</p>
<h3><a class="header" href="#examples-1" id="examples-1">Examples</a></h3>
<pre><code class="language-rust no_run noplaypen">let a = true;
let b: bool = false;

if a &amp;&amp; !b {
    debug(a ^^ b);
};
</code></pre>
<h2><a class="header" href="#integer" id="integer">Integer</a></h2>
<p>Integer types are somewhat different from those of Rust since they are
extended to be able to use any size between 1 and 32 bytes. This feature was
borrowed from Solidity and it helps to reduce the number of constraints and
smart contract size. Internal integer representation uses the BN256 field of
different bitlength.</p>
<h3><a class="header" href="#types-1" id="types-1">Types</a></h3>
<ul>
<li><code>u8</code> .. <code>u248</code>: unsigned integers</li>
<li><code>i8</code> .. <code>i248</code>: signed integers</li>
<li><code>field</code>: the native field integer</li>
</ul>
<p>Integer types bitlength step equals 8, that is, only the following bitlengths
are possible: <code>8</code>, <code>16</code>, ..., <code>240</code>, <code>248</code>.</p>
<p>A <code>field</code> value is a native field element of the elliptic curve used in the
constraint system. It represents an unsigned integer of bitlength equal to the
field modulus length (e.g. for BN256 the field modulus length is <code>254</code> bit).</p>
<p>All the types are represented using <code>field</code> as their basic building block.
When an integer variable is allocated, its bitlength must be enforced in the
constraint system.</p>
<h3><a class="header" href="#literals-1" id="literals-1">Literals</a></h3>
<ul>
<li>decimal: <code>0</code>, <code>1</code>, <code>122</code>, <code>574839572494237242</code></li>
<li>hexadecimal: <code>0x0</code>, <code>0xfa</code>, <code>0x0001</code>, <code>0x1fffDEADffffffffffBEEFffff</code></li>
</ul>
<p>Following the Rust rules, only unsigned integer literals can be expressed, since
the unary minus is not a part of the literal but a standalone operator. Thus,
unsigned values can be implicitly casted to signed ones using the unary minus.</p>
<h3><a class="header" href="#casting" id="casting">Casting</a></h3>
<p>Casting is possible only to a type with greater bitlength. Probably, this
behavior will become less strict in the future.</p>
<h3><a class="header" href="#inference-1" id="inference-1">Inference</a></h3>
<p>If the literal type is not specified, the minimal possible bitlength is inferred.</p>
<h3><a class="header" href="#examples-2" id="examples-2">Examples</a></h3>
<pre><code class="language-rust no_run noplaypen">let a = 0; // u8
let a: i24 = 0; // i24
let b = 256; // u16
let c = -1;  // i8
let c = -129; // i16
let d = 0xff as field; // field
let e: field = 0; // field
</code></pre>
<h1><a class="header" href="#compound-types" id="compound-types">Compound types</a></h1>
<p>Compound types consist of several fields bound together. There are two such types
in ZRust: arrays and tuples.</p>
<h2><a class="header" href="#array" id="array">Array</a></h2>
<p>Arrays are collections of values of the same type sequentially stored in the memory.</p>
<p>Fixed-sized arrays follow the Rust rules. The only exception is the restriction
to constant indexes, that is, you cannot index an array with anything but an
integer literal for now.</p>
<p>Arrays support the index operator, which is explained in detail in <strong>Chapter 5</strong>.</p>
<pre><code class="language-rust no_run noplaypen">let element = fibbonaci[3];
fibbonaci[2] = 1;
</code></pre>
<h2><a class="header" href="#tuple" id="tuple">Tuple</a></h2>
<p>Tuples are anonymous collections of values of different types, sequentially
stored in memory and gathered together due to some logical relations.</p>
<p>Like in Rust, <code>()</code> is the void value, <code>(value)</code> is a parenthesized expression,
and <code>(value,)</code> is a tuple with one element.</p>
<p>Tuple fields can be accessed via the dot operator, which is explained in detail
in <strong>Chapter 5</strong>.</p>
<pre><code class="language-rust no_run noplaypen">let mut tuple: (u8, field) = (0xff, 0 as field);
tuple.0 = 42;
debug(tuple.1);
</code></pre>
<h1><a class="header" href="#custom-types" id="custom-types">Custom types</a></h1>
<p>Structure, enumeration, and function are the custom types. They must be
explicitly declared in the code using the <code>struct</code>, <code>enum</code>, and <code>fn</code> statements
respectively. These types always have a name allowing to distinguish them,
even if their signatures are the same. Thus, compound types facilitate type
checking and reduce code verbosity and repeatability.</p>
<h2><a class="header" href="#structure" id="structure">Structure</a></h2>
<p>A structure is a custom data type that lets you name and package together
multiple related values that make up a meaningful group. Structures allow you
to easily build complex data types and pass them around your code with as little
verbosity as possible.</p>
<p>Structure fields can be accessed via the dot operator, which is explained in
detail in <strong>Chapter 5</strong>.</p>
<pre><code class="language-rust no_run noplaypen">struct Person {
    age: u8,
    id: u64,
}

let mut person = struct Person {
    age: 24,
    id: 123456789 as u64,
};
person.age = 25;
</code></pre>
<h2><a class="header" href="#enumeration" id="enumeration">Enumeration</a></h2>
<p>Enums allow you to define a type by enumerating its possible values. Only simple
C-like enums are supported for now, which are groups of constants, following
the Rust syntax:</p>
<pre><code class="language-rust no_run noplaypen">enum Order {
    FIRST = 0,
    SECOND = 1,
}
</code></pre>
<p>Enum values can be used with <code>match</code> expressions to define the behavior in every
possible case:</p>
<pre><code class="language-rust no_run noplaypen">let value = Order::FIRST;
let result = match value {
    Order::FIRST =&gt; do_this(),
    Order::SECOND =&gt; do_that(),
};
</code></pre>
<p>The enum values can be implicitly casted to unsigned integers of enough
bitlength using <code>let</code> statements or explicitly using the <code>as</code> operator:</p>
<pre><code class="language-rust no_run noplaypen">let x = Order::FIRST; // the type is Order (inference)
let y: u8 = Order::SECOND; // the type is u8 (implicit casting)
let z = Order::SECOND as u8; // the type is u8 (explicit casting)
</code></pre>
<h2><a class="header" href="#function" id="function">Function</a></h2>
<p>The function is the only callable type in ZRust and it closely follows the Rust
syntax. However, R1CS specifics require that functions must be executed completely,
thus there is no <code>return</code> statement in ZRust. The only way to return a value is
to specify it as the last unterminated statement of the function block.</p>
<p>Functions consist of several parts: the name, arguments, return type, and the
code block. The name is the function type name and it uniquely defines a function.
The arguments can be only passed by value, and the function result can only be
returned by value. If the return type is omitted, the function is considered
to return the result of type <code>()</code>. The code block can access the global scope,
but it has no information about where the function has been called from.</p>
<pre><code class="language-rust no_run noplaypen">const GLOBAL: u8 = 31;

fn wierd_sum(a: u8, b: u8) -&gt; u8 {
    side_effect(); // a statement
    a + b + GLOBAL // return value
}

let result = wierd_sum(42, 27);
std::require(result == 100);
</code></pre>
<h1><a class="header" href="#other-types" id="other-types">Other types</a></h1>
<p>Other types do not belong to any type class but provide some features which
may be changed in the future. One such type is the string.</p>
<h2><a class="header" href="#string" id="string">String</a></h2>
<p>For now, strings have very limited implementation and usability.</p>
<p>The string type exists only in the literal form and can only appear as the
second argument of the <code>require</code> function:</p>
<pre><code class="language-rust no_run noplaypen">std::require(true != false, &quot;mega ultra extra total global example&quot;);
</code></pre>
<h1><a class="header" href="#statements" id="statements">Statements</a></h1>
<p>The basic element of the ZRust program is <strong>the statement</strong>.</p>
<p>Statements are divided into several types:</p>
<ol>
<li>Declaration statements</li>
<li>Expression statements</li>
<li>Control statements</li>
</ol>
<h1><a class="header" href="#declaration-statements" id="declaration-statements">Declaration statements</a></h1>
<p>The declaration statements declare a new item, that is, a type, variable or module.</p>
<h2><a class="header" href="#let-variable-declaration" id="let-variable-declaration"><code>let</code> variable declaration</a></h2>
<p><code>let [mut] {identifier}[: {type}] = {expression};</code></p>
<p>The <code>let</code> declaration behaves just like in Rust, but it does not allow
uninitialized variables.</p>
<p>The type is optional and is used mostly to cast integer literal or double-check
the expression result type, otherwise, it is inferred.</p>
<pre><code class="language-rust no_run noplaypen">let mut variable: field = 0;
</code></pre>
<h2><a class="header" href="#type-alias-declaration" id="type-alias-declaration"><code>type</code> alias declaration</a></h2>
<p><code>type {identifier} = {type};</code></p>
<p>The <code>type</code> statement declares a type alias to avoid repeating complex types.</p>
<pre><code class="language-rust no_run noplaypen">type Alias = (field, u8, [field; 8]);
</code></pre>
<h2><a class="header" href="#struct-type-declaration" id="struct-type-declaration"><code>struct</code> type declaration</a></h2>
<p>The <code>struct</code> statement declares a structure.</p>
<pre><code class="language-rust no_run noplaypen">struct Data {
    a: field,
    b: u8,
    c: (),
}
</code></pre>
<h2><a class="header" href="#enum-type-declaration" id="enum-type-declaration"><code>enum</code> type declaration</a></h2>
<p>The <code>enum</code> statement declares an enumeration.</p>
<pre><code class="language-rust no_run noplaypen">enum List {
    A = 1,
    B = 2,
    C = 3,
}
</code></pre>
<h2><a class="header" href="#fn-type-declaration" id="fn-type-declaration"><code>fn</code> type declaration</a></h2>
<p>The <code>fn</code> statement declares a function.</p>
<pre><code class="language-rust no_run noplaypen">fn sum(a: u8, b: u8) -&gt; u8 {
    a + b
}
</code></pre>
<h2><a class="header" href="#mod-module-declaration" id="mod-module-declaration"><code>mod</code> module declaration</a></h2>
<p><code>mod {identifier};</code></p>
<p>The <code>mod</code> statement declares a new module and behaves the same way as in Rust.</p>
<h2><a class="header" href="#use-module-import" id="use-module-import"><code>use</code> module import</a></h2>
<p><code>use {path};</code></p>
<p>The <code>use</code> statement imports an item from another namespace and behaves the same
way as in Rust.</p>
<h1><a class="header" href="#expression-statements" id="expression-statements">Expression statements</a></h1>
<h2><a class="header" href="#expression" id="expression">Expression</a></h2>
<p>The expression statement is an expression terminated with a <code>;</code> in order
to ignore its result. The most common use is the assignment to a mutable
variable:</p>
<pre><code class="language-rust no_run noplaypen">let mut a = 0;
a = 42; // an expression statement ignoring the '()' result of the assignment
</code></pre>
<p>For for information on expressions, check the <strong>Chapter 6</strong>.</p>
<h2><a class="header" href="#semicolons" id="semicolons">Semicolons</a></h2>
<p>In contrast with Rust, expression statements must be always terminated with <code>;</code>
in ZRust to get rid of some ambiguities regarding block and conditional
expressions. Let us compare the examples of Rust and ZRust to illustrate the
problem.</p>
<pre><code class="language-rust no_run noplaypen">fn blocks() -&gt; i32 {
    {
        get_unit()
    } // a statement, but only because the block result is ()
    {
        get_integer()
    } // a return expression, only because the block result is an integer
}
</code></pre>
<p>In the Rust example above, the blocks are completely identical, but their semantic
meaning depends on the block return type. ZRust solves this problem by enforcing
all expression statements to be explicitly terminated with a semicolon, like in
the following ZRust example:</p>
<pre><code class="language-rust no_run noplaypen">fn blocks() -&gt; i32 {
    {
        get_unit()
    }; // a statement, because it is explicitly terminated with a semicolon
    {
        get_integer()
    } // a return expression, because it goes the last in the function block
}
</code></pre>
<p>Conditional and match expressions follow the same rules as simple blocks.</p>
<h1><a class="header" href="#control-statements" id="control-statements">Control statements</a></h1>
<p>Control statements do neither ignore the result nor declare a new item. The
only such statement is the <code>for-while</code> loop.</p>
<h2><a class="header" href="#for-while-loop" id="for-while-loop"><code>for-while</code> loop</a></h2>
<p><code>for {identifier} in {integer}..{integer} [while {expression}] { ... }</code></p>
<p>The <code>for</code> loop statement behaves just like in Rust, but it is merged with the
<code>while</code> loop, so the optional <code>while</code> condition is checked before each iteration
of the loop. The <code>while</code> condition expression has access to the inner scope and
can use its variables and the loop iterator.</p>
<pre><code class="language-rust no_run noplaypen">for i in 0..10 while i % x != 8 {
    // do something
};
</code></pre>
<p>Only integer literals can be used as the bounds of the iterator range for now.</p>
<h1><a class="header" href="#operators" id="operators">Operators</a></h1>
<h2><a class="header" href="#path-resolution" id="path-resolution">Path resolution</a></h2>
<p><code>::</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Module or enum</li>
<li>Identifier or module</li>
</ol>
<p><strong>Returns</strong> the second operand.</p>
<h2><a class="header" href="#array-indexing" id="array-indexing">Array indexing</a></h2>
<p><code>[]</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Array expression</li>
<li>Integer literal</li>
</ol>
<p><strong>Returns</strong> an array element or error.</p>
<p><strong>Note</strong>: only integer literals can be array indexes now.</p>
<h2><a class="header" href="#field-access" id="field-access">Field access</a></h2>
<p><code>.</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Tuple expression</li>
<li>Integer literal</li>
</ol>
<p><strong>Returns</strong> a tuple or structure element or error.</p>
<h2><a class="header" href="#unary-minus" id="unary-minus">Unary minus</a></h2>
<p><code>-</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression</li>
</ol>
<p><strong>Returns</strong> the integer result.</p>
<h2><a class="header" href="#logical-not" id="logical-not">Logical NOT</a></h2>
<p><code>!</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Boolean expression</li>
</ol>
<p><strong>Returns</strong> the boolean result.</p>
<h2><a class="header" href="#casting-1" id="casting-1">Casting</a></h2>
<p><code>as</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression</li>
<li>Integer type</li>
</ol>
<p><strong>Returns</strong> the integer result.</p>
<p>Casting allowed:</p>
<ul>
<li>integers to types of greater bitlength</li>
<li>enums to integers of enough bitlength</li>
</ul>
<pre><code class="language-rust no_run noplaypen">let a = -1; // inference
let b: u16 = a as u16; // ok, casted to the opposite sign with greater bitlength 
let c: u8 = Order::First; // casting to an integer of enough bitlength
</code></pre>
<h2><a class="header" href="#multiplication" id="multiplication">Multiplication</a></h2>
<p><code>*</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression</li>
<li>Integer expression</li>
</ol>
<p><strong>Returns</strong> the integer result.</p>
<h2><a class="header" href="#division" id="division">Division</a></h2>
<p><code>/</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression</li>
<li>Integer expression</li>
</ol>
<p><strong>Returns</strong> the integer result.</p>
<h2><a class="header" href="#remainder" id="remainder">Remainder</a></h2>
<p><code>%</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression</li>
<li>Integer expression</li>
</ol>
<p><strong>Returns</strong> the integer result.</p>
<h2><a class="header" href="#addition" id="addition">Addition</a></h2>
<p><code>+</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression</li>
<li>Integer expression</li>
</ol>
<p><strong>Returns</strong> the integer result.</p>
<h2><a class="header" href="#subtraction" id="subtraction">Subtraction</a></h2>
<p><code>-</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression</li>
<li>Integer expression</li>
</ol>
<p><strong>Returns</strong> the integer result.</p>
<h2><a class="header" href="#equality" id="equality">Equality</a></h2>
<p><code>==</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer <strong>or</strong> boolean expression</li>
<li>Integer <strong>or</strong> boolean expression</li>
</ol>
<p><strong>Returns</strong> the boolean result.</p>
<h2><a class="header" href="#non-equality" id="non-equality">Non-equality</a></h2>
<p><code>!=</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer <strong>or</strong> boolean expression</li>
<li>Integer <strong>or</strong> boolean expression</li>
</ol>
<p><strong>Returns</strong> the boolean result.</p>
<h2><a class="header" href="#lesser-or-equals" id="lesser-or-equals">Lesser or equals</a></h2>
<p><code>&lt;=</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression</li>
<li>Integer expression</li>
</ol>
<p><strong>Returns</strong> the boolean result.</p>
<h2><a class="header" href="#greater-or-equals" id="greater-or-equals">Greater or equals</a></h2>
<p><code>&gt;=</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression</li>
<li>Integer expression</li>
</ol>
<p><strong>Returns</strong> the boolean result.</p>
<h2><a class="header" href="#lesser" id="lesser">Lesser</a></h2>
<p><code>&lt;</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression</li>
<li>Integer expression</li>
</ol>
<p><strong>Returns</strong> the boolean result.</p>
<h2><a class="header" href="#greater" id="greater">Greater</a></h2>
<p><code>&gt;</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression</li>
<li>Integer expression</li>
</ol>
<p><strong>Returns</strong> the boolean result.</p>
<h2><a class="header" href="#logical-and" id="logical-and">Logical AND</a></h2>
<p><code>&amp;&amp;</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Boolean expression</li>
<li>Boolean expression</li>
</ol>
<p><strong>Returns</strong> the boolean result.</p>
<h2><a class="header" href="#logical-xor" id="logical-xor">Logical XOR</a></h2>
<p><code>^^</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Boolean expression</li>
<li>Boolean expression</li>
</ol>
<p><strong>Returns</strong> the boolean result.</p>
<h2><a class="header" href="#logical-or" id="logical-or">Logical OR</a></h2>
<p><code>||</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Boolean expression</li>
<li>Boolean expression</li>
</ol>
<p><strong>Returns</strong> the boolean result.</p>
<h2><a class="header" href="#exclusive-range-todo" id="exclusive-range-todo">Exclusive range (TODO)</a></h2>
<p><code>..</code></p>
<h2><a class="header" href="#inclusive-range-todo" id="inclusive-range-todo">Inclusive range (TODO)</a></h2>
<p><code>..=</code></p>
<h2><a class="header" href="#assignment" id="assignment">Assignment</a></h2>
<p><code>=</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Place expression</li>
<li>Value expression</li>
</ol>
<p><strong>Returns</strong> <code>()</code>.</p>
<h1><a class="header" href="#operator-precedence" id="operator-precedence">Operator precedence</a></h1>
<p>The top one is executed first.</p>
<table><thead><tr><th>Operator</th><th>Associativity</th></tr></thead><tbody>
<tr><td>::</td><td>left to right</td></tr>
<tr><td>[] .</td><td>left to right</td></tr>
<tr><td>- !</td><td>unary</td></tr>
<tr><td>as</td><td>left to right</td></tr>
<tr><td>* / %</td><td>left to right</td></tr>
<tr><td>+ -</td><td>left to right</td></tr>
<tr><td>== != &lt;= &gt;= &lt; &gt;</td><td>parenthesis</td></tr>
<tr><td>&amp;&amp;</td><td>left to right</td></tr>
<tr><td>^^</td><td>left to right</td></tr>
<tr><td>⎮⎮</td><td>left to right</td></tr>
<tr><td>.. ..=</td><td>single</td></tr>
<tr><td>=</td><td>single</td></tr>
</tbody></table>
<h1><a class="header" href="#expressions" id="expressions">Expressions</a></h1>
<p>Expressions consist of operands and operators.</p>
<p>Operators have already been described in <strong>Chapter 6</strong>.</p>
<h2><a class="header" href="#operands" id="operands">Operands</a></h2>
<p>Any syntax constructions computed into values can be used in expressions.
ZRust does all the type checking at compile-time, so you can build expressions
of arbitrary complexity without caring about safety.
However, you should care about readability and maintainability, since there are
probably other people going to work with your code.</p>
<h1><a class="header" href="#virtual-machine" id="virtual-machine">Virtual machine</a></h1>
<p>ZRust code is compiled into bytecode which can be run by ZRust VM.</p>
<p>ZRust VM is a virtual machine that serves three purposes: executing arbitrary
computations, generating zero-knowledge proof of performed computations, and
verification of the provided proof without knowing the input data.</p>
<p>ZRust VM is a stack-based virtual machine which is similar to many others like
the Python VM. Even though the VM is designed considering specifics and
limitations of zero-knowledge computations, bytecode instructions only
manipulate data on the stack while all zero-knowledge constraints are
automatically applied by the virtual machine.</p>
<h1><a class="header" href="#appendix" id="appendix">Appendix</a></h1>
<p>The following sections contain reference material you may find useful in
your ZRust journey.</p>
<h1><a class="header" href="#lexical-grammar" id="lexical-grammar">Lexical grammar</a></h1>
<p>These are the ZRust lexical grammar rules in the EWBF notation.</p>
<pre><code>lexeme = comment | identifier | keyword | literal | symbol | EOF ;

comment = single_line_comment | multi_line_comment ;
single_line_comment = '//', ( ? ANY ? - '\n' ), '\n' ;
multi_line_comment = '/*', ( ? ANY ? - '*/' ), '*/' ;

identifier = (
    alpha, { alpha | digit | '_' }
  | '_', alpha, { alpha }
- keyword ) ;

keyword =
    'input'
  | 'witness'
  | 'output'

  | 'let'
  | 'mut'
  | 'type'
  | 'struct'
  | 'enum'
  | 'fn'
  | 'mod'
  | 'use'

  | 'for'
  | 'in'
  | 'while'
  | 'if'
  | 'else'
  | 'match'

  | 'bool'
  | 'u8' | 'u16' | 'u24' | 'u32' | 'u40' | 'u48' | 'u56' | 'u64'
  | 'u72' | 'u80' | 'u88' | 'u96' | 'u104' | 'u112' | 'u120' | 'u128'
  | 'u136' | 'u144' | 'u152' | 'u160' | 'u168' | 'u176' | 'u184' | 'u192'
  | 'u200' | 'u208' | 'u216' | 'u224' | 'u232' | 'u240' | 'u248' | 'field'
  | 'i8' | 'i16' | 'i24' | 'i32' | 'i40' | 'i48' | 'i56' | 'i64'
  | 'i72' | 'i80' | 'i88' | 'i96' | 'i104' | 'i112' | 'i120' | 'i128'
  | 'i136' | 'i144' | 'i152' | 'i160' | 'i168' | 'i176' | 'i184' | 'i192'
  | 'i200' | 'i208' | 'i216' | 'i224' | 'i232' | 'i240' | 'i248'

  | 'true'
  | 'false'

  | 'as'
;

literal = boolean | integer | string ;
boolean = 'true' | 'false' ;
integer =
    '0'
  | digit - '0', { digit }
  | '0x', hex_digit, { hex_digit}
;
string = '&quot;', { ANY - '&quot;' | '\', ANY }, '&quot;' ;

symbol =
    '('
  | ')'
  | '['
  | ']'
  | '{'
  | '}'
  | '_'
  | '.'
  | ':'
  | ';'
  | ','
  | '='
  | '+'
  | '-'
  | '*'
  | '/'
  | '%'
  | '\'
  | '!'
  | '&lt;'
  | '&gt;'
  | '::'
  | '=='
  | '!='
  | '&lt;='
  | '&gt;='  
  | '&amp;&amp;'
  | '^^'
  | '||'
  | '..'
  | '..='
  | '=&gt;'
  | '-&gt;'
;

alpha =
    'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'
  | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N'
  | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U'
  | 'V' | 'W' | 'X' | 'Y' | 'Z' 
  | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g'
  | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n'
  | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u'
  | 'v' | 'w' | 'x' | 'y' | 'z'
;

digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;

hex_digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
  | 'A' | 'B' | 'C' | 'D' | 'E' | 'F'
  | 'a' | 'b' | 'c' | 'd' | 'e' | 'f'
;

</code></pre>
<h1><a class="header" href="#syntax-grammar" id="syntax-grammar">Syntax grammar</a></h1>
<p>These are the ZRust syntax grammar rules in the EWBF notation.</p>
<pre><code>(* Domain *)
file = binary | library ;

binary = { outer_statement } ;

library = { outer_statement } ;

type =
    'bool'
  | 'u8' | 'u16' | 'u24' | 'u32' | 'u40' | 'u48' | 'u56' | 'u64'
  | 'u72' | 'u80' | 'u88' | 'u96' | 'u104' | 'u112' | 'u120' | 'u128'
  | 'u136' | 'u144' | 'u152' | 'u160' | 'u168' | 'u176' | 'u184' | 'u192'
  | 'u200' | 'u208' | 'u216' | 'u224' | 'u232' | 'u240' | 'u248' | 'field'
  | 'i8' | 'i16' | 'i24' | 'i32' | 'i40' | 'i48' | 'i56' | 'i64'
  | 'i72' | 'i80' | 'i88' | 'i96' | 'i104' | 'i112' | 'i120' | 'i128'
  | 'i136' | 'i144' | 'i152' | 'i160' | 'i168' | 'i176' | 'i184' | 'i192'
  | 'i200' | 'i208' | 'i216' | 'i224' | 'i232' | 'i240' | 'i248'
  | '[', type, ';', integer, ']'
  | '(', { type }, ')'
  | identifier
;

field = identifier, ':', type ;
field_list = [ field, { ',', field } ] ;

variant = identifier, '=', integer ;
variant_list = [ variant, { ',', variant } ] ;

(* Statements *)
outer_statement =
    type_statement
  | struct_statement
  | enum_statement
  | fn_statement
  | mod_statement
  | use_statement

inner_statement =
    empty_statement
  | let_statement
  | loop_statement
  | expression
';' ;

empty_statement = ;
let_statement = 'let', [ 'mut' ], identifier, [ ':', type ], '=', expression ;
loop_statement = 'for', identifier, 'in', integer, '..' | '..=', integer, [ 'while', expression ], block_expression ;
type_statement = 'type', identifier, '=', type ;
struct_statement = 'struct', field_list ;
enum_statement = 'enum', variant_list ;
fn_statement = 'fn', identifier, '(', field_list, ')', [ '-&gt;', type ], block_expression ;
mod_statement = 'mod', identifier ;
use_statement = 'use', path_expression ;

(* Expressions *)
expression = operand_or, { '||', operand_or } ;
operand_or = operand_xor, { '^^', operand_xor } ;
operand_xor = operand_and, { '&amp;&amp;', operand_and } ;
operand_and = operand_comparison, [ '==' | '!=' | '&gt;=' | '&lt;=' | '&gt;' | '&lt;', operand_comparison ] ;
operand_comparison = operand_add_sub, { '+' | '-', operand_add_sub } ;
operand_add_sub = operand_mul_div_rem, { '*' | '/' | '%', operand_mul_div_rem } ;
operand_mul_div_rem = operand_as, { 'as', type } ;
operand_as =
    '-' | '!', operand_as
  | operand_access, { '[', integer, ']' | '.', integer | '.', identifier | '(', expression_list, ')' }
operand_access
    tuple_expression
  | block_expression
  | array_expression
  | conditional_expression
  | match_expression
  | struct_expression
  | literal
  | path_expression
;

expression_list = [ expression, { ',', expression } ] ;

block_expression = '{', { inner_statement }, [ expression ], '}' ;

conditional_expression = 'if', expression, block_expression, [ 'else', conditional_expression | block_expression ] ;

match_expression = 'match', expression, '{', { literal, '=&gt;', expression, ',' }, '}' ;

array_expression =
    '[', [ expression, { ',', expression } ] ']'
  | '[', expression, ';', integer, ']'
;

tuple_expression =
    '(', ')'
  | '(', expression, ')'
  | '(', expression, ',', [ expression, { ',', expression } ], ')'
;

struct_expression = 'struct', path_expression, [ '{', field_list, '}' ] ;

path_expression = identifier, { '::', identifier } ;

</code></pre>
<h1><a class="header" href="#keywords" id="keywords">Keywords</a></h1>
<h4><a class="header" href="#declarations" id="declarations">Declarations</a></h4>
<pre><code class="language-rust no_run noplaypen">let
mut
type
struct
enum
fn
</code></pre>
<h4><a class="header" href="#controls" id="controls">Controls</a></h4>
<pre><code class="language-rust no_run noplaypen">for
in
while
if
else
match
</code></pre>
<h4><a class="header" href="#types-2" id="types-2">Types</a></h4>
<pre><code class="language-rust no_run noplaypen">bool
u8 ... u248
i8 ... i248
field
</code></pre>
<h4><a class="header" href="#literals-2" id="literals-2">Literals</a></h4>
<pre><code class="language-rust no_run noplaypen">true
false
</code></pre>
<h4><a class="header" href="#operators-1" id="operators-1">Operators</a></h4>
<pre><code class="language-rust no_run noplaypen">as
</code></pre>
<h2><a class="header" href="#reserved" id="reserved">Reserved</a></h2>
<pre><code class="language-rust no_run noplaypen">pub
ref
</code></pre>
<h1><a class="header" href="#built-in-functions-1" id="built-in-functions-1">Built-in functions</a></h1>
<h1><a class="header" href="#compiler-cli" id="compiler-cli">Compiler CLI</a></h1>
<h2><a class="header" href="#interface" id="interface">Interface</a></h2>
<pre><code>zrustc 0.5.0
The ZRust compiler

USAGE:
    zrustc [FLAGS] --input &lt;input&gt; --output &lt;output&gt;

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
    -i, --input &lt;input&gt;      Specifies the *.zrs input file name
    -o, --output &lt;output&gt;    Specifies the *.zrsb output file name
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
