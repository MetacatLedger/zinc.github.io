<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ZRust</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="language/introduction.html">Introduction</a></li><li><a href="language/01-design/01-overview.html"><strong aria-hidden="true">1.</strong> Design</a></li><li><ol class="section"><li><a href="language/01-design/02-comparison.html"><strong aria-hidden="true">1.1.</strong> Comparison to Rust</a></li></ol></li><li><a href="language/02-examples/01-overview.html"><strong aria-hidden="true">2.</strong> Examples</a></li><li><ol class="section"><li><a href="language/02-examples/02-binary.html"><strong aria-hidden="true">2.1.</strong> Binary</a></li><li><a href="language/02-examples/03-library.html"><strong aria-hidden="true">2.2.</strong> Library</a></li></ol></li><li><a href="language/03-concepts/01-overview.html"><strong aria-hidden="true">3.</strong> Concepts</a></li><li><ol class="section"><li><a href="language/03-concepts/02-variables.html"><strong aria-hidden="true">3.1.</strong> Variables</a></li><li><a href="language/03-concepts/03-types/00-overview.html"><strong aria-hidden="true">3.2.</strong> Types</a></li><li><ol class="section"><li><a href="language/03-concepts/03-types/01-scalar.html"><strong aria-hidden="true">3.2.1.</strong> Scalar</a></li><li><a href="language/03-concepts/03-types/02-compound.html"><strong aria-hidden="true">3.2.2.</strong> Compound</a></li><li><a href="language/03-concepts/03-types/03-custom.html"><strong aria-hidden="true">3.2.3.</strong> Custom</a></li><li><a href="language/03-concepts/03-types/04-other.html"><strong aria-hidden="true">3.2.4.</strong> Other</a></li></ol></li></ol></li><li><a href="language/04-statements/00-overview.html"><strong aria-hidden="true">4.</strong> Statements</a></li><li><ol class="section"><li><a href="language/04-statements/01-declaration.html"><strong aria-hidden="true">4.1.</strong> Declaration</a></li><li><a href="language/04-statements/02-expression.html"><strong aria-hidden="true">4.2.</strong> Expression</a></li><li><a href="language/04-statements/03-control.html"><strong aria-hidden="true">4.3.</strong> Control</a></li></ol></li><li><a href="language/05-operators/00-overview.html"><strong aria-hidden="true">5.</strong> Operators</a></li><li><ol class="section"><li><a href="language/05-operators/01-precedence.html"><strong aria-hidden="true">5.1.</strong> Precedence</a></li></ol></li><li><a href="language/06-expressions/00-overview.html"><strong aria-hidden="true">6.</strong> Expressions</a></li><li><a href="language/07-project-structure/00-overview.html"><strong aria-hidden="true">7.</strong> Program structure</a></li><li><a href="language/appendix/_overview.html"><strong aria-hidden="true">8.</strong> Appendix</a></li><li><ol class="section"><li><a href="language/appendix/A-grammar-lexical.html"><strong aria-hidden="true">8.1.</strong> A - Lexical grammar</a></li><li><a href="language/appendix/B-grammar-syntax.html"><strong aria-hidden="true">8.2.</strong> B - Syntax grammar</a></li><li><a href="language/appendix/C-keywords.html"><strong aria-hidden="true">8.3.</strong> C - Keywords</a></li></ol></li><li><a href="compiler.html">Compiler CLI</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">ZRust</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>ZRust is a secure-by-design language for constructing R1CS ZKP-circuits and
smart contracts.</p>
<p>Most of the modern languages, both general purpose and domain specific, do not
usually provide the satisfying degree of security in order to develop reliable
software. Security and safety aspects are crucial for developing smart
contracts, since they deal with digital assets of real people. On the contrary,
some languages are secure and safe enough, but they overwhelm developers with
overcomplicated syntax, thus decreasing their popularity by increasing the
learning curve. ZRust is designed to break this stereotype and prove that a
smart contract language can be reliable and simple at the same time.</p>
<p>The decision to borrow the Rust syntax and semantics has been made. So,
ZRust is a subset of Rust with minor differences dictated by the subtleties
of R1CS circuits. It is easily learnable by any developer familiar with
Rust, Golang, C++ or other C-like languages. Also, experience with Solidity
will help in understanding some smart contract specifics.</p>
<p>The language is under heavy development, so a great deal of the book contents
will be eventually rewritten. However, the basic language philosophy principles,
such as security and simplicity, will never be questioned.</p>
<h1><a class="header" href="#design" id="design">Design</a></h1>
<p>The goal of ZRust is to make writing zero-knowledge programs and smart
contracts easy. It is being designed with the following principles in mind:</p>
<ul>
<li><strong>Security</strong>. It should be easy to write deterministic and secure programs.
Conversely, it should be hard to write code in order to exploit some possible
vulnerabilities found in other programming languages.</li>
<li><strong>Safety</strong>. The language must enforce the most strict semantics available,
such as strong static explicit type system.</li>
<li><strong>Efficiency</strong>. Code should compile to the most efficient circuit possible.</li>
<li><strong>Cost-exposition</strong>. Costs that cannot be optimized efficiently
must be made explicit to the developers. An example is the requirement to
explicitly specify the loop range with constants.</li>
<li><strong>Simplicity</strong>. Anyone familiar with C-like languages (Javascript, Java,
Golang, C++, Rust, Solidity) should be able to learn ZRust quickly and with
minimum effort.</li>
<li><strong>Readability</strong>. The code in ZRust should be easy to read for anybody
familiar with the C++ language family. There should be no counter-intuitive
concepts.</li>
<li><strong>Minimalism</strong>. Less code is better. There should ideally be
only one way to do something efficiently. Complexity should be reduced.</li>
<li><strong>Expressiveness</strong>. The language should be powerful enough to make building
complex programs easy.</li>
</ul>
<h1><a class="header" href="#comparison-to-rust" id="comparison-to-rust">Comparison to Rust</a></h1>
<p>ZRust is designed specifically for ZKP-based smart contract development, so some
differences from Rust are inevitable.</p>
<h2><a class="header" href="#types" id="types">Types</a></h2>
<p>Obviously we need to adapt the type system to be efficiently representable in
finite fields, which are the basic building block of R1CS. The current type
system mostly follows Rust, but some aspects are borrowed from smart contract
languages. For example, ZRust provides integer types with 1-byte step sizes,
like those in Solidity.</p>
<h2><a class="header" href="#ownership-and-borrowing" id="ownership-and-borrowing">Ownership and borrowing</a></h2>
<p>Memory management is very different in R1CS circuits compared to the von Neumann
architecture. Also, since R1CS does not imply parallel programming patterns,
a lot of elements of the Rust design would be unnecessary and redundant.
The decision is to copy data by default without moving ownership. The borrowing
mechanism is still being designed, but probably, only immutable references will
be allowed in the near future.</p>
<h1><a class="header" href="#examples" id="examples">Examples</a></h1>
<p>The examples in this chapter will illustrate various ZRust concepts and help you
to understand its advantages. Also, there is a ZRust playground under
development which will allow you to try everything yourself.</p>
<h1><a class="header" href="#binary" id="binary">Binary</a></h1>
<pre><pre class="playpen"><code class="language-rust">/// 
/// './main.rs'
///
/// Proves a knowledge of a cubic root `r` for a given public input `x`.
///

mod simple_math;

use simple_math::cube;

struct Input {
    x: u128,
}

struct Witness {
    r: u128,
}

struct Output {}

fn main(input: Input, witness: Witness) -&gt; Output {
    require(x == cube(r), &quot;x == r ^ 3&quot;);
    Output {}
}
</code></pre></pre>
<h1><a class="header" href="#library" id="library">Library</a></h1>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// 
/// './lib.rs'
/// 
/// Returns x^3.
/// 
fn cube(x: u128) -&gt; u128 {
    let mut r = x;
    for i in 0..2 {
        r = r * x;
    }
    r
}
#}</code></pre></pre>
<h1><a class="header" href="#concepts" id="concepts">Concepts</a></h1>
<p>This chapter describes the ZRust language concepts. Here you will learn about
variables and types.</p>
<h1><a class="header" href="#variables" id="variables">Variables</a></h1>
<p>As it was said before, ZRust is mostly about safety and security. Thus,
variables are immutable by default. If you are going to change their values,
you must explicitly mark them as mutable. It protects your data from accidental
mutating where the compiler is unable to check your intentions.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn test() {
    let x = 0;
    // compile error: mutating an immutable variable
    // x = 42;

    let mut y = 0;
    y = 42; // ok
}
#}</code></pre></pre>
<p>If you are familiar with Rust, you will not have any troubles understanding this
concept, since the syntax and semantics are almost identical. However, pattern
matching and destructuring are not implemented yet.</p>
<p>Immutable variables are similar to constants. Like with constants, you cannot
change the immutable variable value. However, constants have some further
restrictions: they cannot infer their type, can be declared only in the global
scope, and obviously cannot be marked as mutable.</p>
<p>In contrast to Rust, variables can only be declared in functions. If you need a
global variable, you should declare a constant. This limitation is devised to
prevent unwanted side effects, polluting the global namespace, and bad design.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
const VALUE: field = 0; // ok

fn test() {
    // compile error: a constant not in the global scope
    // const VALUE: field = 0;
}
#}</code></pre></pre>
<p>Variable shadowing can be a convenient feature, but ZRust is going to enforce
warning-as-error development workflow, forbidding shadowing as a potentially
unsafe trick. You should use mutable variables and type suffixes if you have
several variables with similar logical meaning.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn test() {
    let mut x = 5;
    {
        // compile error: redeclared variable 'x'
        // let x = 25;
    }
    // compile error: redeclared variable 'x'
    // let x = 25;

    x = 25; // ok
}
#}</code></pre></pre>
<h1><a class="header" href="#types-1" id="types-1">Types</a></h1>
<p>ZRust is a statically typed language, thus all the variables must have a type
known at the compile time. Strict type system allows to catch the majority of
runtime errors, which are very common to dynamically typed languages. ZRust type
system closely resembles that of Rust, but with some modifications, limitations
and restrictions.</p>
<p>Types are divided into three major classes: scalar, compound, and custom.
Unit, boolean, integer, and string are the scalar types and you can learn more
about them in <strong>subchapter 1</strong>.
Arrays and tuples are the compound types explained in <strong>subchapter 2</strong>.
Structures, enumerations and functions are custom types described in <strong>subchapter 3</strong>.
Custom types differ from others in having a user-defined name and special
declaration syntax.
The string type does not belong to any of the classes described above, since
it is used mostly to annotate statements and provide error messages. For more
details, check the <strong>subchapter 4</strong>.</p>
<p>You can also declare type aliases in ZRust, which allow you to shorten type
signatures of complex types by giving them a name:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type ComplexType = [(u8, [bool; 8], field); 16];

fn example(data: ComplexType) {}
#}</code></pre></pre>
<h2><a class="header" href="#casting-and-conversions" id="casting-and-conversions">Casting and conversions</a></h2>
<p>The language enforces static strong explicit type semantics. It is the most
strict type system available, since safety is above everything. However, some
inference abilities will not do any harm, so you do not have to specify types
in places where they are highly obvious.
Binary arithmetic operators always require their arguments to be of the same type.</p>
<h3><a class="header" href="#explicit" id="explicit">Explicit</a></h3>
<p>Type conversions can be only performed on the integer and enumeration types with
the <code>as</code> operator. <strong>Chapter 5</strong> explains the operator behavior in details.</p>
<h3><a class="header" href="#implicit" id="implicit">Implicit</a></h3>
<p>The <code>let</code> statement can perform implicit type casting of integers if the type
is specified to the left of the assignment symbol. Let us examine the statement:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a: field = 42 as u32;
#}</code></pre></pre>
<ol>
<li><code>42</code> is inferred as a value of type <code>u8</code>.</li>
<li><code>42</code> is casted from <code>u8</code> to <code>u32</code>.</li>
<li>The expression <code>42 as u32</code> result is casted to <code>field</code>.</li>
<li>The field value is assigned to the variable <code>a</code>.</li>
</ol>
<p>The second case of implicit casting is the negation operator, which always
returns a signed integer type value of the same bitlength, regardless of the
input argument.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let positive = 100; // u8
let negative = -positive; // i8
#}</code></pre></pre>
<p><strong>Chapter 5</strong> explains the negation operator with more detail.</p>
<h3><a class="header" href="#inference" id="inference">Inference</a></h3>
<p>For now, ZRust infers types in two cases: integer literals and <code>let</code> bindings.</p>
<p>Integer literals are always inferred as values of the minimal possible size.
That is, <code>255</code> is a <code>u8</code> value, whereas <code>256</code> is a <code>u16</code> value. Signed integers
must be implicitly casted using the negation operator.</p>
<p>The <code>let</code> statement can infer types in case its type is not specified.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let value = 0xffffffff_ffffffff_ffffffff_ffffffff;
#}</code></pre></pre>
<p>In the example above, the <code>value</code> variable gets type <code>u128</code>, since 128 bytes
are enough to represent the value <code>0xffffffff_ffffffff_ffffffff_ffffffff</code>;</p>
<h1><a class="header" href="#scalar-types" id="scalar-types">Scalar types</a></h1>
<p>Scalar types are also called primitive types and contain a single value.</p>
<h2><a class="header" href="#unit" id="unit">Unit</a></h2>
<p>The unit type and value are described with empty round parenthesis <code>()</code> and
have no differences from the same type in Rust. Values of that type are
implicitly returned from functions, blocks, and other expressions which do not
return a value explicitly. Also, this type can be used as a placeholder for
input, witness and output types of the <code>main</code> function.</p>
<p><code>()</code> is the literal for both unit type and value. The unit type values cannot be
used by any operators or casted back and forth.</p>
<p>The unit type can exist as a standalone value:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = (); // ()
#}</code></pre></pre>
<p>It can be returned by blocks or functions:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn check(value: bool) {
    // several statements
};

let y = check(true); // y is ()
#}</code></pre></pre>
<h2><a class="header" href="#boolean" id="boolean">Boolean</a></h2>
<p><code>bool</code> is the boolean type keyword.</p>
<p>Its internal representation uses the BN256 field of bitlength <code>1</code>. But in
general, its behavior is indistinguishable from the same type from Rust or other
C-like languages.</p>
<p>Boolean values cannot be casted to or from.</p>
<h3><a class="header" href="#literals" id="literals">Literals</a></h3>
<p><code>true</code> and <code>false</code>.</p>
<h3><a class="header" href="#examples-1" id="examples-1">Examples</a></h3>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = true;
let b: bool = false;

if a &amp;&amp; !b {
    debug(a ^^ b);
};
#}</code></pre></pre>
<h2><a class="header" href="#integer" id="integer">Integer</a></h2>
<p>Integer types are somewhat different from those of Rust, since they are
extended to be able to use any size between 1 and 32 bytes. This feature was
borrowed from Solidity and it helps to reduce the number of constraints and
smart contract size. Internal integer representation uses the BN256 field of
different bitlength.</p>
<h3><a class="header" href="#types-2" id="types-2">Types</a></h3>
<ul>
<li><code>u8</code> .. <code>u248</code>: unsigned integers</li>
<li><code>i8</code> .. <code>i248</code>: signed integers</li>
<li><code>field</code>: the native field integer</li>
</ul>
<p>Integer types bitlength step equals 8, that is, only the following bitlengths
are possible: <code>8</code>, <code>16</code>, ..., <code>240</code>, <code>248</code>.</p>
<p><code>field</code> is a native field element of the elliptic curve used in the constraint
system. It represents an unsigned integer of bitlength equal to the field
modulus length (e.g. for BN256 the field modulus length is <code>254</code> bit).</p>
<p>All the types are represented using <code>field</code> as their basic building block.
When integers variables are allocated, their bitlength must be enforced in the
constraint system.</p>
<h3><a class="header" href="#literals-1" id="literals-1">Literals</a></h3>
<ul>
<li>decimal: <code>0</code>, <code>1</code>, <code>122</code>, <code>574839572494237242</code></li>
<li>hexadecimal: <code>0x0</code>, <code>0xfa</code>, <code>0x0001</code>, <code>0x1fffDEADffffffffffBEEFffff</code></li>
</ul>
<p>Following the Rust rules, only unsigned integer literals can be expressed, since
the unary minus is not a part of the literal but a standalone operator. Thus,
unsigned values can be implicitly casted to signed ones using the unary minus.</p>
<h3><a class="header" href="#casting" id="casting">Casting</a></h3>
<p>Casting is possible only to a type with greater bitlength. Probably, this
behavior will become less strict in the future.</p>
<h3><a class="header" href="#inference-1" id="inference-1">Inference</a></h3>
<p>If the literal type is not specified, the minimal possible bitlength is inferred.</p>
<h3><a class="header" href="#examples-2" id="examples-2">Examples</a></h3>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = 0; // u8
let a: i24 = 0; // i24
let b = 256; // u16
let c = -1;  // i8
let c = -129; // i16
let d = 0xff as field; // field
let e: field = 0; // field
#}</code></pre></pre>
<h1><a class="header" href="#compound-types" id="compound-types">Compound types</a></h1>
<p>Compound types consist of several fields bound together. There are two such types
in ZRust: arrays and tuples.</p>
<h2><a class="header" href="#array" id="array">Array</a></h2>
<p>Arrays are collections of values of the same type sequentially stored in the memory.</p>
<p>Fixed-sized arrays follow the Rust rules. The only exception is the restriction
to constant indexes, that is, you cannot index an array with anything but an
integer literal for now.</p>
<p>Arrays support the index operator, which is explained in detail in <strong>Chapter 5</strong>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let element = fibbonaci[3];
fibbonaci[2] = 1;
#}</code></pre></pre>
<h2><a class="header" href="#tuple" id="tuple">Tuple</a></h2>
<p>Tuples are anonymous collections of values of different types, sequentially
stored in memory and gathered together due to some logical relations.</p>
<p>Like in Rust, <code>()</code> is the void value, <code>(value)</code> is a parenthesized expression,
and <code>(value,)</code> is a tuple with one element.</p>
<p>Tuple fields can be accessed via the dot operator, which is explained in details
in <strong>Chapter 5</strong>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut tuple: (u8, field) = (0xff, 0 as field);
tuple.0 = 42;
debug(tuple.1);
#}</code></pre></pre>
<h1><a class="header" href="#custom-types" id="custom-types">Custom types</a></h1>
<p>Structures, enumerations and function are the custom types. They must be
explicitly declared in the code using the <code>struct</code>, <code>enum</code>, and <code>fn</code> statements
respectively. These types always have a name, which allows to distinguish them,
even if their signatures are the same. Thus, compound types facilitate type
checking and reduce code verbosity and repeatability.</p>
<h2><a class="header" href="#structure" id="structure">Structure</a></h2>
<p>A structure is a custom data type that lets you name and package together
multiple related values that make up a meaningful group. Structures allow you
to easily build complex data types and pass them around your code with as little
verbosity as possible.</p>
<p>Structure fields can be accessed via the dot operator, which is explained in details
in <strong>Chapter 5</strong>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Person {
    age: u8,
    id: u64,
}

let mut person = struct Person {
    age: 24,
    id: 123456789 as u64,
};
person.age = 25;
#}</code></pre></pre>
<h2><a class="header" href="#enumeration" id="enumeration">Enumeration</a></h2>
<p>Enums allow you to define a type by enumerating its possible values. Only simple
C-like enums are supported for now, which are basically groups of constants,
following the Rust syntax:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Order {
    FIRST = 0,
    SECOND = 1,
}
#}</code></pre></pre>
<p>Enum values can be used with <code>match</code> expressions to define the behavior in every
possible case:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let value = Order::FIRST;
let result = match value {
    Order::FIRST =&gt; do_this(),
    Order::SECOND =&gt; do_that(),
};
#}</code></pre></pre>
<p>The enum values can be implicitly casted to unsigned integers of enough
bitlength using <code>let</code> statements or explicitly using the <code>as</code> operator:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = Order::FIRST; // the type is Order (inference)
let y: u8 = Order::SECOND; // the type is u8 (implicit casting)
let z = Order::SECOND as u8; // the type is u8 (explicit casting)
#}</code></pre></pre>
<h2><a class="header" href="#function" id="function">Function</a></h2>
<p>The function is the only callable type in ZRust and it closely follows the Rust
syntax. However, R1CS specifics require that functions must be executed completely,
thus there are no <code>return</code> statement in ZRust. The only way to return a value is
to specify it as the last unterminated statement of the function block.</p>
<p>Functions consist of several parts: the name, arguments, return type and the
code block. The name is the function type name and it uniquely defines a function.
The arguments can be only passed by value, and the function result can only be
returned by value. If the return type is omitted, the function is considered
to return the result of type <code>()</code>. The code block can access the global scope,
but it has no information about where the function has been called from.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
const GLOBAL: u8 = 31;

fn wierd_sum(a: u8, b: u8) -&gt; u8 {
    side_effect(); // a statement
    a + b + GLOBAL // return value
}

let result = wierd_sum(42, 27);
std::require(result == 100);
#}</code></pre></pre>
<h1><a class="header" href="#other-types" id="other-types">Other types</a></h1>
<p>Other types does not belong to any type classes, but provide some features which
may be changed in the future. One of such types is the string.</p>
<h2><a class="header" href="#string" id="string">String</a></h2>
<p>For now, strings have very limited implementation and usability.</p>
<p>The string type exists only in the literal form and can only appear as the
second argument of the <code>require</code> function:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
std::require(true != false, &quot;mega ultra extra total global example&quot;);
#}</code></pre></pre>
<h1><a class="header" href="#statements" id="statements">Statements</a></h1>
<p>The basic element of the ZRust program is <strong>the statement</strong>.</p>
<p>Statements are divided into several types:</p>
<ol>
<li>Declaration statements</li>
<li>Expression statements</li>
<li>Control statements</li>
</ol>
<h1><a class="header" href="#declaration-statements" id="declaration-statements">Declaration statements</a></h1>
<p>The declaration statements declare a new item, that is, a type, variable or module.</p>
<h2><a class="header" href="#let-variable-declaration" id="let-variable-declaration"><code>let</code> variable declaration</a></h2>
<p><code>let [mut] {identifier}[: {type}] = {expression};</code></p>
<p>The <code>let</code> declaration behaves just like in Rust, but it does not allow
uninitialized variables.</p>
<p>The type is optional and is used mostly to cast integer literal or double check
the expression result type, otherwise it is inferred.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut variable: field = 0;
#}</code></pre></pre>
<h2><a class="header" href="#type-alias-declaration" id="type-alias-declaration"><code>type</code> alias declaration</a></h2>
<p><code>type {identifier} = {type};</code></p>
<p>The <code>type</code> statement declares a type alias to avoid repeating complex types.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type Alias = (field, u8, [field; 8]);
#}</code></pre></pre>
<h2><a class="header" href="#struct-type-declaration" id="struct-type-declaration"><code>struct</code> type declaration</a></h2>
<p>The <code>struct</code> statement declares a structure.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Data {
    a: field,
    b: u8,
    c: (),
}
#}</code></pre></pre>
<h2><a class="header" href="#enum-type-declaration" id="enum-type-declaration"><code>enum</code> type declaration</a></h2>
<p>The <code>enum</code> statement declares an enumeration.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum List {
    A = 1,
    B = 2,
    C = 3,
}
#}</code></pre></pre>
<h2><a class="header" href="#fn-type-declaration" id="fn-type-declaration"><code>fn</code> type declaration</a></h2>
<p>The <code>fn</code> statement declares a function.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn sum(a: u8, b: u8) -&gt; u8 {
    a + b
}
#}</code></pre></pre>
<h2><a class="header" href="#mod-module-declaration" id="mod-module-declaration"><code>mod</code> module declaration</a></h2>
<p><code>mod {identifier};</code></p>
<p>The <code>mod</code> statement declares a new module and behaves the same way as in Rust.</p>
<h2><a class="header" href="#use-module-import" id="use-module-import"><code>use</code> module import</a></h2>
<p><code>use {path};</code></p>
<p>The <code>use</code> statement imports an item from another namespace and behaves the same
way as in Rust.</p>
<h1><a class="header" href="#expression-statements" id="expression-statements">Expression statements</a></h1>
<h2><a class="header" href="#empty" id="empty">Empty</a></h2>
<p>The semicolon statement <code>;</code> is an empty statement.</p>
<p>It is made mostly to keep backward-compatibility with presence or absence of
semicolons in some possible cases in the future.</p>
<h2><a class="header" href="#expression" id="expression">Expression</a></h2>
<p>The expression statement is an expression terminated with a <code>;</code> in order
to ignore its result. The most common use is the assignment to a mutable
variable:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut a = 0;
a = 42; // an expression statement ignoring the '()' result of the assignment
#}</code></pre></pre>
<p>For for information on expressions, check the <strong>Chapter 6</strong>.</p>
<h2><a class="header" href="#semicolons" id="semicolons">Semicolons</a></h2>
<p>In contrast with Rust, expression statements must be always terminated with <code>;</code>
in ZRust to get rid of some ambiguities regarding block and conditional
expressions. Let us compare the examples of Rust and ZRust to illustrate the
problem.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn blocks() -&gt; i32 {
    {
        get_unit()
    } // a statement, but only because the block result is ()
    {
        get_integer()
    } // a return expression, only because the block result is an integer
}
#}</code></pre></pre>
<p>In the Rust example above, the blocks are completely identical, but their semantic
meaning depends on the block return type. ZRust solves this problem by enforcing
all expression statements to be explictly terminated with a semicolon, like in
the following ZRust example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn blocks() -&gt; i32 {
    {
        get_unit()
    }; // a statement, because it is explicitly terminated with a semicolon
    {
        get_integer()
    } // a return expression, because it goes the last in the function block
}
#}</code></pre></pre>
<p>Conditional and match expressions follow the same rules as simple blocks.</p>
<h1><a class="header" href="#control-statements" id="control-statements">Control statements</a></h1>
<p>Control statements do neither ignore the result nor declare a new item. The
only such statement is the <code>for-while</code> loop.</p>
<h2><a class="header" href="#for-while-loop" id="for-while-loop"><code>for-while</code> loop</a></h2>
<p><code>for {identifier} in {integer}..{integer} [while {expression}] { ... }</code></p>
<p>The <code>for</code> loop statement behaves just like in Rust, but it is merged with the
<code>while</code> loop, so the optional <code>while</code> condition is checked before each iteration
of the loop. The <code>while</code> condition expression has access to the inner scope and
can use its variables and the loop iterator.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for i in 0..10 while i % x != 8 {
    // do something
};
#}</code></pre></pre>
<p>Only integer literals can be used as the bounds of the iterator range for now.</p>
<h1><a class="header" href="#operators" id="operators">Operators</a></h1>
<h2><a class="header" href="#path-resolution" id="path-resolution">Path resolution</a></h2>
<p><code>::</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Module or enum</li>
<li>Identifier or module</li>
</ol>
<p><strong>Returns</strong> the second operand.</p>
<h2><a class="header" href="#array-indexing" id="array-indexing">Array indexing</a></h2>
<p><code>[]</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Array expression</li>
<li>Integer literal</li>
</ol>
<p><strong>Returns</strong> the array element or an out of range error.</p>
<p><strong>Note</strong>: only integer literals can be array indexes now.</p>
<h2><a class="header" href="#field-access" id="field-access">Field access</a></h2>
<p><code>.</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Tuple expression</li>
<li>Integer literal</li>
</ol>
<p><strong>Returns</strong> the tuple or structure element or an nonexistent field error.</p>
<h2><a class="header" href="#unary-minus" id="unary-minus">Unary minus</a></h2>
<p><code>-</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression</li>
</ol>
<p><strong>Returns</strong> the integer result.</p>
<h2><a class="header" href="#logical-not" id="logical-not">Logical NOT</a></h2>
<p><code>!</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Boolean expression</li>
</ol>
<p><strong>Returns</strong> the boolean result.</p>
<h2><a class="header" href="#casting-1" id="casting-1">Casting</a></h2>
<p><code>as</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression</li>
<li>Integer type</li>
</ol>
<p><strong>Returns</strong> the integer result.</p>
<p>Casting allowed:</p>
<ul>
<li>integers to types of greater bitlength</li>
<li>enums to integers of enough bitlength</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = -1; // inference
let b: u16 = a as u16; // ok, casted to the opposite sign with greater bitlength 
let c: u8 = Order::First; // casting to an integer of enough bitlength
#}</code></pre></pre>
<h2><a class="header" href="#multiplication" id="multiplication">Multiplication</a></h2>
<p><code>*</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression</li>
<li>Integer expression</li>
</ol>
<p><strong>Returns</strong> the integer result.</p>
<h2><a class="header" href="#division" id="division">Division</a></h2>
<p><code>/</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression</li>
<li>Integer expression</li>
</ol>
<p><strong>Returns</strong> the integer result.</p>
<h2><a class="header" href="#remainder" id="remainder">Remainder</a></h2>
<p><code>%</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression</li>
<li>Integer expression</li>
</ol>
<p><strong>Returns</strong> the integer result.</p>
<h2><a class="header" href="#addition" id="addition">Addition</a></h2>
<p><code>+</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression</li>
<li>Integer expression</li>
</ol>
<p><strong>Returns</strong> the integer result.</p>
<h2><a class="header" href="#subtraction" id="subtraction">Subtraction</a></h2>
<p><code>-</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression</li>
<li>Integer expression</li>
</ol>
<p><strong>Returns</strong> the integer result.</p>
<h2><a class="header" href="#equality" id="equality">Equality</a></h2>
<p><code>==</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer <strong>or</strong> boolean expression</li>
<li>Integer <strong>or</strong> boolean expression</li>
</ol>
<p><strong>Returns</strong> the boolean result.</p>
<h2><a class="header" href="#non-equality" id="non-equality">Non-equality</a></h2>
<p><code>!=</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer <strong>or</strong> boolean expression</li>
<li>Integer <strong>or</strong> boolean expression</li>
</ol>
<p><strong>Returns</strong> the boolean result.</p>
<h2><a class="header" href="#lesser-or-equals" id="lesser-or-equals">Lesser or equals</a></h2>
<p><code>&lt;=</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression</li>
<li>Integer expression</li>
</ol>
<p><strong>Returns</strong> the boolean result.</p>
<h2><a class="header" href="#greater-or-equals" id="greater-or-equals">Greater or equals</a></h2>
<p><code>&gt;=</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression</li>
<li>Integer expression</li>
</ol>
<p><strong>Returns</strong> the boolean result.</p>
<h2><a class="header" href="#lesser" id="lesser">Lesser</a></h2>
<p><code>&lt;</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression</li>
<li>Integer expression</li>
</ol>
<p><strong>Returns</strong> the boolean result.</p>
<h2><a class="header" href="#greater" id="greater">Greater</a></h2>
<p><code>&gt;</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression</li>
<li>Integer expression</li>
</ol>
<p><strong>Returns</strong> the boolean result.</p>
<h2><a class="header" href="#logical-and" id="logical-and">Logical AND</a></h2>
<p><code>&amp;&amp;</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Boolean expression</li>
<li>Boolean expression</li>
</ol>
<p><strong>Returns</strong> the boolean result.</p>
<h2><a class="header" href="#logical-xor" id="logical-xor">Logical XOR</a></h2>
<p><code>^^</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Boolean expression</li>
<li>Boolean expression</li>
</ol>
<p><strong>Returns</strong> the boolean result.</p>
<h2><a class="header" href="#logical-or" id="logical-or">Logical OR</a></h2>
<p><code>||</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Boolean expression</li>
<li>Boolean expression</li>
</ol>
<p><strong>Returns</strong> the boolean result.</p>
<h2><a class="header" href="#exclusive-range-todo" id="exclusive-range-todo">Exclusive range (TODO)</a></h2>
<p><code>..</code></p>
<h2><a class="header" href="#inclusive-range-todo" id="inclusive-range-todo">Inclusive range (TODO)</a></h2>
<p><code>..=</code></p>
<h2><a class="header" href="#assignment" id="assignment">Assignment</a></h2>
<p><code>=</code></p>
<p><strong>Accepts</strong></p>
<ol>
<li>Place expression</li>
<li>Value expression</li>
</ol>
<p><strong>Returns</strong> <code>()</code>.</p>
<h1><a class="header" href="#operator-precedence" id="operator-precedence">Operator precedence</a></h1>
<p>The top one is executed the first.</p>
<pre><code>|    Operator      |  Associativity  |
|----------------- |-----------------|
|        ::        |  left to right  |
|       [] .       |  left to right  |
|        - !       |      unary      |
|        as        |  left to right  |
|       * / %      |  left to right  |
|        + -       |  left to right  |
|  == != &lt;= &gt;= &lt; &gt; |   parenthesis   |
|        &amp;&amp;        |  left to right  |
|        ^^        |  left to right  |
|        ⎮⎮        |  left to right  |
|      .. ..=      |     single      |
|         =        |     single      |
</code></pre>
<h1><a class="header" href="#expressions" id="expressions">Expressions</a></h1>
<p>Expressions consist of operands and operators.</p>
<p>Operators have already been described in the <strong>Chapter 5</strong>.</p>
<h2><a class="header" href="#operands" id="operands">Operands</a></h2>
<p>Any syntax constructions computed into values can be used in expressions.
ZRust does all the type checking at compile time, so you can build expressions
of arbitrary complexity without caring about safety.
However, you should care about readability and maintainability, since there are
probably other people going to work with your code.</p>
<h1><a class="header" href="#program-structure" id="program-structure">Program structure</a></h1>
<p>A ZRust project consists of a binary file called <code>main.zrs</code> and zero or more
library files whose contents can be imported into the binary file.</p>
<p>Binary file must contain the <code>main</code> function, which accepts two mandatory
arguments for input data and witnesses, and returns the output data.</p>
<p>Library files may contain only declarations of types, functions, and constants.</p>
<h2><a class="header" href="#inputs-witnesses-and-the-output" id="inputs-witnesses-and-the-output">Inputs, witnesses and the output</a></h2>
<pre><pre class="playpen"><code class="language-rust">struct Input {
    {identifier}: {type},
    ...
}

struct Witness {
    {identifier}: {type},
    ...
}

struct Output {
    {identifier}: {type},
    ...
}

fn main(input: Input, witness: Witness) -&gt; Output { Output { ... } }
</code></pre></pre>
<p>Public inputs (defined as the <code>Input</code> type) and secret witness (defined as the
<code>Witness</code> type) are the arguments of the program for which the circuit is
implemented. The prover must provide both public inputs and secret witness data
in order to generate proofs. The verifier must provide the same public input
to verify the satisfiability of the proof.</p>
<p>Inputs, witnesses, and outputs must be defined at the beginning of a circuit.
Variable names for input and witness are declared in the global variable scope.</p>
<p>The output data defined as the <code>Output</code> type contain the result of a
circuit execution.</p>
<p>If either inputs or witnesses are empty, they must be specified as the <code>()</code> type.
If there is no output data, the return type can be omitted like with an
ordinary function.</p>
<h2><a class="header" href="#standard-library" id="standard-library">Standard library</a></h2>
<p>Most of the standard library functions will be embedded into the ZRust virtual
machine, which is described in the <strong>Chapter 8</strong>.</p>
<p>The standard library will provide computation-heavy algorithms like:</p>
<ul>
<li>hashes: <code>sha256</code>, <code>pedersen</code>, <code>poseidon</code>, <code>blake2s</code></li>
<li>signatures: <code>eddsa_verify</code></li>
<li>curve primitives: <code>ecc</code></li>
<li>into_bits / from_bits</li>
</ul>
<h1><a class="header" href="#appendix" id="appendix">Appendix</a></h1>
<p>The following sections contain reference material you may find useful in
your ZRust journey.</p>
<h1><a class="header" href="#lexical-grammar" id="lexical-grammar">Lexical grammar</a></h1>
<p>These are the ZRust lexical grammar rules in the EWBF notation.</p>
<pre><code>lexeme = comment | identifier | keyword | literal | symbol | EOF ;

comment = single_line_comment | multi_line_comment ;
single_line_comment = '//', ( ? ANY ? - '\n' ), '\n' ;
multi_line_comment = '/*', ( ? ANY ? - '*/' ), '*/' ;

identifier = (
    alpha, { alpha | digit | '_' }
  | '_', alpha, { alpha }
- keyword ) ;

keyword =
    'input'
  | 'witness'
  | 'output'

  | 'let'
  | 'mut'
  | 'type'
  | 'struct'
  | 'enum'
  | 'fn'
  | 'mod'
  | 'use'

  | 'for'
  | 'in'
  | 'while'
  | 'if'
  | 'else'
  | 'match'

  | 'bool'
  | 'u8' | 'u16' | 'u24' | 'u32' | 'u40' | 'u48' | 'u56' | 'u64'
  | 'u72' | 'u80' | 'u88' | 'u96' | 'u104' | 'u112' | 'u120' | 'u128'
  | 'u136' | 'u144' | 'u152' | 'u160' | 'u168' | 'u176' | 'u184' | 'u192'
  | 'u200' | 'u208' | 'u216' | 'u224' | 'u232' | 'u240' | 'u248' | 'field'
  | 'i8' | 'i16' | 'i24' | 'i32' | 'i40' | 'i48' | 'i56' | 'i64'
  | 'i72' | 'i80' | 'i88' | 'i96' | 'i104' | 'i112' | 'i120' | 'i128'
  | 'i136' | 'i144' | 'i152' | 'i160' | 'i168' | 'i176' | 'i184' | 'i192'
  | 'i200' | 'i208' | 'i216' | 'i224' | 'i232' | 'i240' | 'i248'

  | 'true'
  | 'false'

  | 'as'
;

literal = boolean | integer | string ;
boolean = 'true' | 'false' ;
integer =
    '0'
  | digit - '0', { digit }
  | '0x', hex_digit, { hex_digit}
;
string = '&quot;', { ANY - '&quot;' | '\', ANY }, '&quot;' ;

symbol =
    '('
  | ')'
  | '['
  | ']'
  | '{'
  | '}'
  | '_'
  | '.'
  | ':'
  | ';'
  | ','
  | '='
  | '+'
  | '-'
  | '*'
  | '/'
  | '%'
  | '\'
  | '!'
  | '&lt;'
  | '&gt;'
  | '::'
  | '=='
  | '!='
  | '&lt;='
  | '&gt;='  
  | '&amp;&amp;'
  | '^^'
  | '||'
  | '..'
  | '..='
  | '=&gt;'
  | '-&gt;'
;

alpha =
    'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'
  | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N'
  | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U'
  | 'V' | 'W' | 'X' | 'Y' | 'Z' 
  | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g'
  | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n'
  | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u'
  | 'v' | 'w' | 'x' | 'y' | 'z'
;

digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;

hex_digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
  | 'A' | 'B' | 'C' | 'D' | 'E' | 'F'
  | 'a' | 'b' | 'c' | 'd' | 'e' | 'f'
;

</code></pre>
<h1><a class="header" href="#syntax-grammar" id="syntax-grammar">Syntax grammar</a></h1>
<p>These are the ZRust syntax grammar rules in the EWBF notation.</p>
<pre><code>(* Domain *)
file = binary | library ;

binary = { statement } ;

library = { statement } ;

type =
    'bool'
  | 'u8' | 'u16' | 'u24' | 'u32' | 'u40' | 'u48' | 'u56' | 'u64'
  | 'u72' | 'u80' | 'u88' | 'u96' | 'u104' | 'u112' | 'u120' | 'u128'
  | 'u136' | 'u144' | 'u152' | 'u160' | 'u168' | 'u176' | 'u184' | 'u192'
  | 'u200' | 'u208' | 'u216' | 'u224' | 'u232' | 'u240' | 'u248' | 'field'
  | 'i8' | 'i16' | 'i24' | 'i32' | 'i40' | 'i48' | 'i56' | 'i64'
  | 'i72' | 'i80' | 'i88' | 'i96' | 'i104' | 'i112' | 'i120' | 'i128'
  | 'i136' | 'i144' | 'i152' | 'i160' | 'i168' | 'i176' | 'i184' | 'i192'
  | 'i200' | 'i208' | 'i216' | 'i224' | 'i232' | 'i240' | 'i248'
  | '[', type, ';', integer, ']'
  | '(', { type }, ')'
  | identifier
;

field = identifier, ':', type ;
field_list = [ field, { ',', field } ] ;

variant = identifier, '=', integer ;
variant_list = [ variant, { ',', variant } ] ;

(* Statements *)
statement =
    empty_statement
  | let_statement
  | loop_statement
  | type_statement
  | struct_statement
  | enum_statement
  | fn_statement
  | mod_statement
  | use_statement
  | expression
';' ;

empty_statement = ;
let_statement = 'let', [ 'mut' ], identifier, [ ':', type ], '=', expression ;
loop_statement = 'for', identifier, 'in', integer, '..' | '..=', integer, [ 'while', expression ], block_expression ;
type_statement = 'type', identifier, '=', type ;
struct_statement = 'struct', field_list ;
enum_statement = 'enum', variant_list ;
fn_statement = 'fn', identifier, '(', field_list, ')', [ '-&gt;', type ], block_expression ;
mod_statement = 'mod', identifier ;
use_statement = 'use', path_expression ;

(* Expressions *)
expression = operand_or, { '||', operand_or } ;
operand_or = operand_xor, { '^^', operand_xor } ;
operand_xor = operand_and, { '&amp;&amp;', operand_and } ;
operand_and = operand_comparison, [ '==' | '!=' | '&gt;=' | '&lt;=' | '&gt;' | '&lt;', operand_comparison ] ;
operand_comparison = operand_add_sub, { '+' | '-', operand_add_sub } ;
operand_add_sub = operand_mul_div_rem, { '*' | '/' | '%', operand_mul_div_rem } ;
operand_mul_div_rem = operand_as, { 'as', type } ;
operand_as =
    '-' | '!', operand_as
  | operand_access, { '[', integer, ']' | '.', integer | '.', identifier | '(', expression_list, ')' }
operand_access
    tuple_expression
  | block_expression
  | array_expression
  | conditional_expression
  | match_expression
  | struct_expression
  | literal
  | path_expression
;

expression_list = [ expression, { ',', expression } ] ;

block_expression = '{', { statement }, [ expression ], '}' ;

conditional_expression = 'if', expression, block_expression, [ 'else', conditional_expression | block_expression ] ;

match_expression = 'match', expression, '{', { literal, '=&gt;', expression, ',' }, '}' ;

array_expression =
    '[', [ expression, { ',', expression } ] ']'
  | '[', expression, ';', integer, ']'
;

tuple_expression =
    '(', ')'
  | '(', expression, ')'
  | '(', expression, ',', [ expression, { ',', expression } ], ')'
;

struct_expression = 'struct', path_expression, [ '{', field_list, '}' ] ;

path_expression = identifier, { '::', identifier } ;

</code></pre>
<h1><a class="header" href="#keywords" id="keywords">Keywords</a></h1>
<h4><a class="header" href="#declarations" id="declarations">Declarations</a></h4>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let
mut
type
struct
enum
fn
#}</code></pre></pre>
<h4><a class="header" href="#controls" id="controls">Controls</a></h4>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for
in
while
if
else
match
#}</code></pre></pre>
<h4><a class="header" href="#types-3" id="types-3">Types</a></h4>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
bool
u8 ... u248
i8 ... i248
field
#}</code></pre></pre>
<h4><a class="header" href="#literals-2" id="literals-2">Literals</a></h4>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
true
false
#}</code></pre></pre>
<h4><a class="header" href="#operators-1" id="operators-1">Operators</a></h4>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
as
#}</code></pre></pre>
<h2><a class="header" href="#reserved" id="reserved">Reserved</a></h2>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub
ref
#}</code></pre></pre>
<h1><a class="header" href="#compiler-cli" id="compiler-cli">Compiler CLI</a></h1>
<h2><a class="header" href="#interface" id="interface">Interface</a></h2>
<pre><code>zrustc 0.5.0
The ZRust compiler

USAGE:
    zrustc.exe [FLAGS] --input &lt;input&gt; --output &lt;output&gt;

FLAGS:
    -h, --help       Prints help information
    -m, --meta       Generates meta info
    -V, --version    Prints version information

OPTIONS:
    -i, --input &lt;input&gt;      Specifies the *.zrs input file name
    -o, --output &lt;output&gt;    Specifies the *.zrsb output file name
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
